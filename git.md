### 什么是版本控制系统
* 记录版本信息(每一次修改记录)
* 方便团队相互之间协作开发

### 常用版本控制系统
* cvs/svn---集中式版本控制系统
> 集中式必须有一个中央总控的服务器，用来存储历史版本和代码信息。但是需要联网才能回退或查看历史版本信息；中央服务器一旦毁坏所有信息全部丢失；所有的上传和下载都是基于文件传输方式完成的，速度会慢
* git---分布式版本控制系统
> 分布式中每个开发者本地就是一个代码管理仓库，以文件流传输文件，速度快

### git工作原理

#### git共分为三个区
* 工作区：可以看到的，并且用来写代码的区域
* 暂存区：临时存储用的
* 历史区：生成历史版本

#### git使用
1. 全局配置基本信息:我是谁?(只需要配置一次)
```
$ git confog -l 查看配置信息
$ git config --global -l 查看全局配置信息
$ git config --global user.name "xxx" 设定用户名为xxxx
$ git config --global user.email "xxx" 设定用户邮箱为xxxx
```
2. 创建仓库，完成版本控制
> 创建本地git仓库
```
$ git init
//会生成一个隐藏文件夹".git",负责记录暂存区和历史区信息,不能删
```
3. 本地编写完代码后(工作区),把文件提交到暂存区
```
$ git status 查看当前文件状态
> 如果文件名显示红色，说明这些文件存在工作区;如果文件名是绿色，说明文件存在暂存区;看不见东西说明所有修改的信息已经提交到历史区
$ git add xxx 把某个文件提交到暂存区
$ git add ./-A 把所有最新修改的文件提交到暂存区
$ git rm --cached <file> 删除暂存区文件(撤销git add操作)
```
4. 把暂存区内容提交到历史区
```
$ git commit -m"描述信息"
> 如果不加-m"描述信息"，git会自动打开一个文本编辑器
$ git log 查看历史版本信息(历史记录) 
$ git reflog 查看历史版本信息(历史记录),包含回滚
$ git reset --hard <版本号>用历史区指定版本替换工作区文件
```
> 每一次提交都相当于将文件复制一份粘贴到下一个区
### github使用
#### 将本地仓库信息提交到远程仓库
* 建立与远程仓库的连接
```
$ git remote -v 查看本地仓库和那些远程仓库链接了
$ git remote add origin <GIT仓库地址> 建立本地仓库与远程仓库的链接，origin可以自己随便改
$ git remote add origin 删除本地仓库与远程仓库的链接，origin可以自己随便改
```
* 代码提交
```
$ git pull origin master 提交前先拉取
$ git push origin master 提交代码
````
#### 记一次提交错误
##### 问题
* 提交时出现了`fatal: refusing to merge unrelated histories`（拒绝合并不相关的历史）    
##### 分析
* 出现这个问题的最主要原因还是在于本地仓库和远程仓库实际上是独立的两个仓库。假如我之前是直接clone的方式在本地建立起远程github仓库的克隆本地仓库就不会有这问题了。
##### 解决
* 在pull命令后紧接着使用--allow-unrelated-history,即`git pull origin master --allow-unrelated-histories`
> 这个执行后以后不用加`--allow-unrelated-history`,也可以正常提交
* 紧接着将本地仓库的提交推送到远程github仓库上，使用的命令是：
```
git push <远程主机名> <本地分支名>:<远程分支名>
也就是  
git push origin master:master
```

### git分支

##### 分支创建
```
git branch <name>
```
#### 切换分支
```
git checkout <name>
```
> 新建的分支并不会自动切换，这时`HEAD`仍然是指向`master`的，需要手动切换，切换后`HEAD`就指向新建的分支了
##### 创建并切换分支
```
git checkout -b <name>
```
##### 查看自己在哪个分支
```
git branch
```
##### 删除分支
```
git branch -d <name>
```
##### 注意事项(test)
1. `HEAD`指向的分支不能删除，如果要删除需要把`HEAD`切换到别的分支
2. 由于 Git 中的 branch 只是`commit`的一个引用，所以删除 branch 的操作只会删掉这个引用，并不会删除任何的 commit。
3. 如果一个 commit 不在任何一个 branch 的「路径」上，(也许可以称为野生 commit？)，那么在一定时间后，它会被 Git 的回收机制删除掉。
4. 出于安全考虑，没有被合并到 master 过的 branch 在删除时会失败(因为怕你误删掉「未完成」的 branch 啊)
> 这种情况如果你确认是要删除这个 branch （例如某个未完成的功能被团队确认永久毙掉了，不再做了），可以把 -d 改成 -D，小写换成大写，就能删除了。
5. git分支本质上是指向某一个版本的指针，仓库中有多少个这样的指针，就有多少个分支
6. 有一个名为HEAD的特殊指针，一般不算做分支，当前在修改哪个分支head就指向哪个分支
7. 切换分支后工作目录中的文件随之会改变
8. 在切换到新分支前必须把旧分支的内容`commit`
